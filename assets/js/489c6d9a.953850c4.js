"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7963],{1502:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var t=o(5893),i=o(1151);const s={id:"change-walkthrough",title:"How the pen tool works",sidebar_label:"How the pen tool works"},a="What happens when you use the pen tool",c={id:"change-walkthrough",title:"How the pen tool works",description:"This is a a walkthrough of how the pen tool works internally. It should give you an idea of how various systems of PixiEditor work together.",source:"@site/../docs/ChangeWalkthrough.mdx",sourceDirName:".",slug:"/change-walkthrough",permalink:"/docs/change-walkthrough",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"change-walkthrough",title:"How the pen tool works",sidebar_label:"How the pen tool works"},sidebar:"docs",previous:{title:"PixiEditor's Core",permalink:"/docs/core-guide"},next:{title:"Toolbars",permalink:"/docs/toolbars"}},r={},d=[{value:"Viewport",id:"viewport",level:3},{value:"IoViewModel, DocumentViewModel",id:"ioviewmodel-documentviewmodel",level:3},{value:"ActionAccumulator",id:"actionaccumulator",level:3},{value:"ChangeableDocument",id:"changeabledocument",level:3},{value:"Back to GUI",id:"back-to-gui",level:3}];function l(e){const n={code:"code",h1:"h1",h3:"h3",p:"p",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"what-happens-when-you-use-the-pen-tool",children:"What happens when you use the pen tool"}),"\n",(0,t.jsx)(n.p,{children:"This is a a walkthrough of how the pen tool works internally. It should give you an idea of how various systems of PixiEditor work together."}),"\n",(0,t.jsx)(n.p,{children:"Let's start from the very beginning, which is when mouse events appear in the UI."}),"\n",(0,t.jsx)(n.h3,{id:"viewport",children:"Viewport"}),"\n",(0,t.jsxs)(n.p,{children:["When you draw on the canvas the mouse events are initially handled inside the ",(0,t.jsx)(n.code,{children:"Viewport"})," user control. There, they are passed to IoViewModel by\r\ncalling its RelayCommands (IoViewModel has relay commands that are bound to Viewport's dependency properties in MainWindow.xaml)."]}),"\n",(0,t.jsx)(n.h3,{id:"ioviewmodel-documentviewmodel",children:"IoViewModel, DocumentViewModel"}),"\n",(0,t.jsx)(n.p,{children:"Here the mouse input is passed to the document you are drawing in."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IoViewModel"})," filters all incoming mouse events to make sure they stay consistent. ",(0,t.jsx)(n.code,{children:"IoViewModel"})," then calls the mouse event handlers of ",(0,t.jsx)(n.code,{children:"ToolsViewModel"})," and\r\n",(0,t.jsx)(n.code,{children:"DocumentManagerViewModel.ActiveDocument"})," which is the currently selected ",(0,t.jsx)(n.code,{children:"DocumentViewModel"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["ToolsViewModel initiates drawing by calling ",(0,t.jsx)(n.code,{children:"DocumentManagerViewModel.ActiveDocument.UsePenTool()"}),". After this call, ",(0,t.jsx)(n.code,{children:"ActiveDocument"})," starts using all incoming\r\nmouse events to control the pen."]}),"\n",(0,t.jsx)(n.h3,{id:"actionaccumulator",children:"ActionAccumulator"}),"\n",(0,t.jsxs)(n.p,{children:["Now we leave the UI layer and start to descend into ",(0,t.jsx)(n.code,{children:"ChangeableDocument"})," which is part of PixiEditor's Core. When UsePenTool() is called, ",(0,t.jsx)(n.code,{children:"ActiveDocument"}),"\r\ncreates a new ",(0,t.jsx)(n.code,{children:"LineBasedPen_Action"})," which contains all the drawing settings (color, stroke width, ...) as well as the initial position on the canvas.\r\nAs you draw, it creates more ",(0,t.jsx)(n.code,{children:"LineBasedPen_Action"}),"s with updated positions. Once you finally stop drawing, an ",(0,t.jsx)(n.code,{children:"EndLineBasedPen_Action"})," is created.\r\nAll of these actions are passed to this document's  ",(0,t.jsx)(n.code,{children:"ActionAccumulator"}),". ",(0,t.jsx)(n.code,{children:"ActionAccumulator"})," passes all of these actions to ",(0,t.jsx)(n.code,{children:"ChangeableDocument"}),", which\r\nprocesses them asynchronously in a separate thread. Meanwhile, the UI thread goes back to processing incoming mouse events."]}),"\n",(0,t.jsx)(n.h3,{id:"changeabledocument",children:"ChangeableDocument"}),"\n",(0,t.jsxs)(n.p,{children:["The actions that ",(0,t.jsx)(n.code,{children:"ChangeableDocument"})," receives are used to control an instance of ",(0,t.jsx)(n.code,{children:"LineBasedPen_UpdateableChange"}),". The instance is created when the first\r\naction is received, and the mouse positions from the following actions are used to update the change. Finally, once ",(0,t.jsx)(n.code,{children:"EndLineBasedPen_Action"})," is received,\r\nthe updateable change gets fully applied."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"LineBasedPen_UpdateableChange"})," uses the ",(0,t.jsx)(n.code,{children:"EnqueueLine"})," method of the target ",(0,t.jsx)(n.code,{children:"ChunkyImage"})," to draw lines. A new line is drawn after every update. In the\r\nend, when the ",(0,t.jsx)(n.code,{children:"Apply"})," function is called, the affected chunks get saved, after which ",(0,t.jsx)(n.code,{children:"CommitChanges"})," is called, solidifying all the drawn lines."]}),"\n",(0,t.jsx)(n.h3,{id:"back-to-gui",children:"Back to GUI"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"LineBasedChange_UpdateableChange"})," emits a new ",(0,t.jsx)(n.code,{children:"LayerImageChunks_ChangeInfo"})," on every update. This change info is passed to UI and used in ",(0,t.jsx)(n.code,{children:"WriteableBitmapUpdater"}),"\r\nto re-render the parts of the main ",(0,t.jsx)(n.code,{children:"WriteableBitmap"}),"s that were changed. The main canvas you see in the GUI is one of those bitmaps, so this is when you see the\r\nnew stroke segment that you've just drawn."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>c,a:()=>a});var t=o(7294);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);