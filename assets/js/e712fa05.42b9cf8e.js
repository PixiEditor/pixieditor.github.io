"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6793],{8054:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=t(5893),r=t(1151);const i={id:"core-guide",title:"PixiEditor's Core",sidebar_label:"PixiEditor's Core"},s="PixiEditor's Core",o={id:"core-guide",title:"PixiEditor's Core",description:"ChangeableDocument",source:"@site/../docs/CoreGuide.mdx",sourceDirName:".",slug:"/core-guide",permalink:"/docs/core-guide",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"core-guide",title:"PixiEditor's Core",sidebar_label:"PixiEditor's Core"},sidebar:"docs",previous:{title:"PixiEditor's GUI",permalink:"/docs/ui-guide"},next:{title:"How the pen tool works",permalink:"/docs/change-walkthrough"}},c={},d=[{value:"ChangeableDocument",id:"changeabledocument",level:2},{value:"Changes",id:"changes",level:3},{value:"Regular Change",id:"regular-change",level:4},{value:"UpdateableChange",id:"updateablechange",level:4},{value:"LayerImageChunks_ChangeInfo",id:"layerimagechunks_changeinfo",level:4},{value:"ChunkyImage",id:"chunkyimage",level:2},{value:"How ChangeableDocument uses ChunkyImages",id:"how-changeabledocument-uses-chunkyimages",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"pixieditors-core",children:"PixiEditor's Core"}),"\n",(0,a.jsx)(n.h2,{id:"changeabledocument",children:"ChangeableDocument"}),"\n",(0,a.jsxs)(n.p,{children:["ChangeableDocument is a system used to keep track of all changes done to a document.\r\nThe system is implemented in the ",(0,a.jsx)(n.code,{children:"ChangeableDocument"})," project and it is the main part of PixiEditor that enables undo and redo functionality."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Document"})," class stores most of the data of a single document. This includes document dimensions, all layers with their bitmaps, blend modes,\r\nall folders, selection, reference layer, and other stuff. The data can be freely read from the UI, but the only way to write into it\r\nis by using the change pipeline implemented in the ",(0,a.jsx)(n.code,{children:"DocumentChangeTracker"})," class."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"DocumentChangeTracker"})," class implements a pipeline which accepts ",(0,a.jsx)(n.code,{children:"IAction"})," instances, modifies the ",(0,a.jsx)(n.code,{children:"Document"})," based on them,\r\nand returns ",(0,a.jsx)(n.code,{children:"IChangeInfo"})," instances. ",(0,a.jsx)(n.code,{children:"IAction"})," instances describe user's actions. For example, ",(0,a.jsx)(n.code,{children:"ResizeCanvas_Action"})," is created\r\nand passed down the pipeline when the user resizes the canvas. It contains the new canvas size.\r\nAfter accepting the ",(0,a.jsx)(n.code,{children:"ResizeCanvas_Action"})," ",(0,a.jsx)(n.code,{children:"DocumentChangeTracker"})," creates a new instances of the change that corresponds to it, in this case ",(0,a.jsx)(n.code,{children:"ResizeCanvas_Change"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The GUI passes actions to ",(0,a.jsx)(n.code,{children:"DocumentChangeTracker"})," from the ",(0,a.jsx)(n.code,{children:"ActionAccumulator"})," class."]}),"\n",(0,a.jsx)(n.h3,{id:"changes",children:"Changes"}),"\n",(0,a.jsx)(n.h4,{id:"regular-change",children:"Regular Change"}),"\n",(0,a.jsxs)(n.p,{children:['The "change" is an object that describes some modification made to the\r\ndocument, like changing it\'s size. Changes have two main methods: ',(0,a.jsx)(n.code,{children:"Apply"})," and ",(0,a.jsx)(n.code,{children:"Revert"}),", used for applying and reverting the change.\r\nThese methods directly write into the contents of the ",(0,a.jsx)(n.code,{children:"Document"})," class."]}),"\n",(0,a.jsxs)(n.p,{children:["If we take changing document size as an example, ",(0,a.jsx)(n.code,{children:"Apply"})," method applies the change, in this case,\r\nit resizes the document to the new requested size, cropping the layer bitmaps. ",(0,a.jsx)(n.code,{children:"Revert"})," goes the other way:\r\nit restores the original size of the canvas, resizes the layer bitmaps back to the original size, and draws the areas on the edges that\r\nwere previously cut away. All data required to apply and revert the change is saved inside the change itself."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Apply"})," and ",(0,a.jsx)(n.code,{children:"Revert"})," functions return zero, one, or multiple instances of ",(0,a.jsx)(n.code,{children:"IChangeInfo"}),". Each instance of ",(0,a.jsx)(n.code,{children:"IChangeInfo"}),"\r\nconcretely describes a change made to one or multiple properties of ",(0,a.jsx)(n.code,{children:"Document"}),', for example "Document size property changed from 64x64\r\nto 128x128". These ChangeInfos are passed to the UI, and they are utilized to update the state of the UI.']}),"\n",(0,a.jsx)(n.h4,{id:"updateablechange",children:"UpdateableChange"}),"\n",(0,a.jsx)(n.p,{children:"Some changes can't be applied right away. Let's take using a lasso tool to select an area as an example. When using\r\na lasso tool, you first hold down left mouse button, then select the area, then release the button, and only then the\r\nfinal area is known. This means that the lasso change needs to get updates continiously while you are selecting."}),"\n",(0,a.jsxs)(n.p,{children:["This is what ",(0,a.jsx)(n.code,{children:"UpdateableChange"})," is for. It has an ",(0,a.jsx)(n.code,{children:"ApplyTemporarily"})," function that accepts updated data and returns\r\n",(0,a.jsx)(n.code,{children:"IChangeInfo"}),"'s. ",(0,a.jsx)(n.code,{children:"ApplyTemporarily"})," is very similar to ",(0,a.jsx)(n.code,{children:"Apply"}),", but it can be called multiple times while you are selecting\r\nthe area, and once you are done ",(0,a.jsx)(n.code,{children:"Apply"})," is still called. If an updateable change gets reverted and then re-applied\r\n",(0,a.jsx)(n.code,{children:"ApplyTemporarily"})," is not called."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"UpdateableChange"}),"'s have two corresponding ",(0,a.jsx)(n.code,{children:"IAction"}),"'s: the first one implements ",(0,a.jsx)(n.code,{children:"IStartUpdateChangeAction"}),"\r\nand is used to start and update the change; the second one implements ",(0,a.jsx)(n.code,{children:"IEndChangeAction"})," and it indicates the end of\r\nthe change."]}),"\n",(0,a.jsx)(n.p,{children:"Here is an example of how you'd use actions to execute updateable changes. This example changes layer/folder opacity,\r\nlike you would while dragging the opacity slider."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// user started dragging the slider, start changing opacity of layer/folder with guid memberGuid\r\n// initial value - 1.0f\r\n// this will create an updateable change and call it's `ApplyTemporarily`\r\nHelpers.ActionAccumulator.AddActions(new StructureMemberOpacity_Action(memberGuid, 1.0f));\r\n...\r\n// some time later, user dragged the slider to 0.5, update opacity to 0.5f\r\n// this will call `ApplyTemporarily` of the active updateable change\r\nHelpers.ActionAccumulator.AddActions(new StructureMemberOpacity_Action(memberGuid, 0.5f));\r\n...\r\n// some time later, when the user let go of the slider, end the change\r\n// this calls `Apply` of the active updateable change\r\nHelpers.ActionAccumulator.AddFinishedActions(new EndStructureMemberOpacity_Action());\n"})}),"\n",(0,a.jsx)(n.h4,{id:"layerimagechunks_changeinfo",children:"LayerImageChunks_ChangeInfo"}),"\n",(0,a.jsxs)(n.p,{children:["Whenever something is drawn on one of the layer bitmaps, the GUI needs to know what area was updated.\r\nChangeableDocument uses ",(0,a.jsx)(n.code,{children:"LayerImageChunks_ChangeInfo"})," to pass the updated areas to the GUI."]}),"\n",(0,a.jsx)(n.h2,{id:"chunkyimage",children:"ChunkyImage"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ChunkyImageLib"})," provides a bitmap class. ",(0,a.jsx)(n.code,{children:"ChunkyImage"}),"'s are used to store the contents of a layer and it's mask.\r\nYou can draw on ",(0,a.jsx)(n.code,{children:"ChunkyImage"})," by calling methods that enqueue various drawing operations."]}),"\n",(0,a.jsx)(n.p,{children:"The drawing operations can be cancelled, allowing you to preview the changes before committing them.\r\nFor example, cancelling is used when transforming an area of the canvas, since the app needs to display the transformed image\r\nwhile it is being moved around. On every position change the old image drawing operation is cancelled,\r\nand a new one is enqueued in the new position. Other examples include drawing shapes, using brushes, and in general to\r\nanything that requires continious input from the user with immediate visual feedback."}),"\n",(0,a.jsxs)(n.p,{children:["Inside ",(0,a.jsx)(n.code,{children:"ChunkyImage"}),', the image is stored as a set of 256x256 segments, or chunks. The drawing operations are applied individually and\r\nindependently to each chunk. They are applied in a lazy fashion, chunks are updated to the latest version only if you\r\ntry to access them. Moreover, there is an option to render chunks in low resolution. All of this enables PixiEditor to\r\ndisplay the above mentioned "continuous" operations in a very efficient way: parts of the image not currently on display\r\naren\'t being rendered, and if you zoom far enough the rendering system switches to using a low resolution.']}),"\n",(0,a.jsx)(n.h2,{id:"how-changeabledocument-uses-chunkyimages",children:"How ChangeableDocument uses ChunkyImages"}),"\n",(0,a.jsxs)(n.p,{children:["In general, we draw on ",(0,a.jsx)(n.code,{children:"ChunkyImage"}),"s from various ",(0,a.jsx)(n.code,{children:"Change"}),"s and ",(0,a.jsx)(n.code,{children:"UpdateableChange"}),"s. As an example, let's take the ",(0,a.jsx)(n.code,{children:"Apply"}),"\r\nfunction of ",(0,a.jsx)(n.code,{children:"ReplaceColor_Change"}),". ",(0,a.jsx)(n.code,{children:"ReplaceColor_Change"})," operates on all layers, replacing one color with another, e.g.\r\nall red #FF0000 pixels are replaced by green #00FF00 pixels."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public override OneOf<None, IChangeInfo, List<IChangeInfo>> Apply(Document target, bool firstApply, out bool ignoreInUndo)\r\n{\r\n\t...\r\n\t// initialize a dictionary where old versions of the chunks will be stored\r\n\t// they are needed cause the change can get reverted in the future\r\n\tsavedChunks = new();\r\n\t\r\n\tList<IChangeInfo> infos = new();\r\n\t// for each layer\r\n\ttarget.ForEveryMember(member =>\r\n\t{\r\n\t\tif (member is not Layer layer)\r\n\t\t\treturn;\r\n\t\t\r\n\t\t// enqueue a color replacing operation in layer's ChunkyImage\r\n\t\tlayer.LayerImage.EnqueueReplaceColor(oldColor, newColor);\r\n\t\t\r\n\t\t// find all chunks affected by currently enqueued operations\r\n\t\tHashSet<VecI>? chunks = layer.LayerImage.FindAffectedChunks();\r\n\t\t\r\n\t\t// save these chunks\r\n\t\tCommittedChunkStorage storage = new(layer.LayerImage, chunks);\r\n\t\tsavedChunks[layer.GuidValue] = storage;\r\n\t\t\r\n\t\t// fully commit changes\r\n\t\tlayer.LayerImage.CommitChanges();\r\n\t\t\r\n\t\t// create a new changeinfo for this layer\r\n\t\tinfos.Add(new LayerImageChunks_ChangeInfo(layer.GuidValue, chunks));\r\n\t});\r\n\t// if no layers were modified, don't save this change in the undo/redo history\r\n\tignoreInUndo = !savedChunks.Any();\r\n\t\r\n\t// return all created infos\r\n\treturn infos;\r\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notice how we first enqueue changes in ChunkyImage, then get affected chunks, save them in ",(0,a.jsx)(n.code,{children:"CommittedChunkStorage"}),",\r\nthen commit them. This is a very common pattern, shared by many changes. ",(0,a.jsx)(n.code,{children:"ApplyTemporarily"})," functions of\r\n",(0,a.jsx)(n.code,{children:"UpdateableChange"}),"s usually don't commit the changes, as they may need to be cancelled on the next update (next\r\ncall to ",(0,a.jsx)(n.code,{children:"ApplyTemporarily"}),"). Instead the changes are committed in the ",(0,a.jsx)(n.code,{children:"Apply"})," function."]})]})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>s});var a=t(7294);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);