"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/2022/05/02/drawing-contest","metadata":{"permalink":"/blog/2022/05/02/drawing-contest","source":"@site/blog/2022-05-02-drawing-contest.mdx","title":"\ud83c\udf89 Celebratory Drawing Contest \ud83c\udf89","description":"Celebratory drawing contest for 100th members of PixiEditor Discord server.","date":"2022-05-02T00:00:00.000Z","formattedDate":"May 2, 2022","tags":[{"label":"pixel-art","permalink":"/blog/tags/pixel-art"},{"label":"contest","permalink":"/blog/tags/contest"}],"readingTime":0.46,"truncated":true,"authors":[{"name":"Krzysztof Krysi\u0144ski","title":"PixiEditor Creator","url":"https://krysinski.me","imageURL":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4"}],"frontMatter":{"title":"\ud83c\udf89 Celebratory Drawing Contest \ud83c\udf89","author":"Krzysztof Krysi\u0144ski","author_title":"PixiEditor Creator","author_url":"https://krysinski.me","author_image_url":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4","tags":["pixel-art","contest"],"keywords":["pixel-art","contest","discord"],"description":"Celebratory drawing contest for 100th members of PixiEditor Discord server."},"nextItem":{"title":"Devlog 1 v0.1.7","permalink":"/blog/2021/11/13/devlog1"}},"content":"\ud83c\udf89 Our Discord server is growing fast and recently we\'ve reached 100 members! To \\r\\ncelebrate this achievement we\'ve decided to create a drawing contest. \ud83c\udf89\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n# Important info\\r\\n\\r\\n## \ud83c\udf81 What is the prize?\\r\\n\\r\\n\ud83e\udd47 1st place: Discord Nitro for 1 month\\r\\n\\r\\n\ud83e\udd48 2nd place: Discord Nitro Classic for 1 month\\r\\n\\r\\n## When?\\r\\n\\r\\nThe contest finishes 28.05.2022 at 2:59 PM GMT+1\\r\\n\\r\\n## Where?\\r\\n\\r\\n[On our Discord](https://discord.gg/nHgJDYrG4s?event=969232310622900275)\\r\\n\\r\\n## What\'s the topic?\\r\\n\\r\\n**Coziness**\\r\\n\\r\\n![Coziness](https://preview.redd.it/hs6ijh75xaw81.png?width=500&format=png&auto=webp&s=b07f45c13a191f3d582d270d42f36babe2b6ea5e)\\r\\n\\r\\n# Rules\\r\\n\\r\\nYou can find the rules [on this channel](https://discord.gg/kTyKJXHebK). Check out topmost message or pinned messages.\\r\\n\\r\\nGood luck!"},{"id":"/2021/11/13/devlog1","metadata":{"permalink":"/blog/2021/11/13/devlog1","source":"@site/blog/2021-11-13-devlog1.mdx","title":"Devlog 1 v0.1.7","description":"Current status of PixiEditor version v0.1.7 development.","date":"2021-11-13T00:00:00.000Z","formattedDate":"November 13, 2021","tags":[{"label":"pixieditor","permalink":"/blog/tags/pixieditor"},{"label":"progress","permalink":"/blog/tags/progress"},{"label":"devlog","permalink":"/blog/tags/devlog"}],"readingTime":2.965,"truncated":true,"authors":[{"name":"Krzysztof Krysi\u0144ski","title":"PixiEditor Creator","url":"https://krysinski.me","imageURL":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4"}],"frontMatter":{"title":"Devlog 1 v0.1.7","author":"Krzysztof Krysi\u0144ski","author_title":"PixiEditor Creator","author_url":"https://krysinski.me","author_image_url":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4","tags":["pixieditor","progress","devlog"],"keywords":["devlog","pixieditor","pixel-art editor"],"description":"Current status of PixiEditor version v0.1.7 development."},"prevItem":{"title":"\ud83c\udf89 Celebratory Drawing Contest \ud83c\udf89","permalink":"/blog/2022/05/02/drawing-contest"},"nextItem":{"title":"How to write a Todo list app in 10 lines of code in pure C# [no dependencies]","permalink":"/blog/2021/08/06/todo-csharp"}},"content":"Hello pixel makers, welcome to PixiEditor v0.1.7 development blog post. We have exciting news to share\\r\\nabout our latest version. A major rework is going on, there are lots of new features and bug fixes.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n# What has been going on for the past few months\\r\\n\\r\\nWe\'ve decided to rework the most important part of PixiEditor, the drawing backend, from the ground up.\\r\\nThe rework will open a lot of doors for us, from a huge performance boost to an easier and quicker\\r\\ncross-platform port. Thus the version 0.1.7 mostly has performance improvements and optimizations.\\r\\nApart from that, we are working really hard on fixing existing bugs (and trying not to create more), adding\\r\\nnew and exciting features, improving UI, etc.\\r\\n\\r\\n# Port to SkiaSharp\\r\\n\\r\\nFrom the v0.1.7 on, PixiEditor will use Skia as the drawing backend. Skia is an extremely performant image processing library made by Google.\\r\\nWith it, we managed to increase drawing speed to the point where a pen size of 300px is actually usable.\\r\\n\\r\\nWhile those are great news we are still facing some issues that are yet to be solved for a stable release.\\r\\nAlmost every aspect of the core code was affected, and we had to rewrite a lot of crucial components, such as\\r\\nthe undo system, tools, custom layer rendering, and much more.\\r\\n\\r\\nNew versus old comparison video: \\r\\n<video width=\\"700\\" controls>\\r\\n  <source src=\\"/videos/skia.mkv\\" type=\\"video/mp4\\"/>\\r\\n  Your browser does not support the video tag.\\r\\n</video>\\r\\n\\r\\n# New features\\r\\n\\r\\nPixiEditor still lacks many features, and we are adding more and more of them in each version.\\r\\nThe same goes for the one below.\\r\\n\\r\\n## Layer grouping and hierarchy\\r\\n\\r\\nThis is the biggest feature coming to v0.1.7. From now on you\'ll be able to create layer groups and\\r\\nenhance the structure of your drawings. It took us almost 4 months to implement and while it is still not perfect,\\r\\nwe are pretty happy with the way it works already.\\r\\n\\r\\n<video width=\\"700\\" controls>\\r\\n  <source src=\\"/videos/groups.mkv\\" type=\\"video/mp4\\"/>\\r\\n  Your browser does not support the video tag.\\r\\n</video>\\r\\n\\r\\n## Reference layer\\r\\n\\r\\nAnother interesting feature we implemented is the reference layer. Oftentimes while testing PixiEditor\\r\\nwe noticed that it would be convenient to have a full-resolution image as a background to our drawings. That was how\\r\\nthe reference layer came to life. With this feature you\'ll be able to select any image from the disk and it will fit your canvas\\r\\nin a uniform size. \\r\\n\\r\\n<video width=\\"700\\" controls>\\r\\n  <source src=\\"/videos/reference-layer.mp4\\" type=\\"video/mp4\\"/>\\r\\n  Your browser does not support the video tag.\\r\\n</video>\\r\\n\\r\\n## Rotate and flip document/layers\\r\\n\\r\\nPretty self-explanatory. PixiEditor didn\'t have any rotation and flipping options, so now you\'ll be able\\r\\nto rotate the whole document and the individual layers (currently in 90-degree increments, a custom angle option is planned for v0.2).\\r\\n\\r\\n<video width=\\"700\\" controls>\\r\\n  <source src=\\"/videos/rotate-flip.mkv\\" type=\\"video/mp4\\"/>\\r\\n  Your browser does not support the video tag.\\r\\n</video>\\r\\n\\r\\n## Magic wand tool\\r\\n\\r\\nMore tools, more selection capabilities. The magic wand tool selects an area that has the same color. Simple and effective.\\r\\n\\r\\n# Other changes and improvements\\r\\n\\r\\nWe replaced WPF Extended Toolkit zoombox with a custom one made to be more responsive and\\r\\nuser-friendly. There are a lot of new changes, and many of them are not mentioned in this post.\\r\\n\\r\\nNumerous bugs were fixed (and a few new ones were introduced as well).\\r\\n\\r\\n# Summary\\r\\n\\r\\nWe are happy with the current status of PixiEditor v0.1.7, but It\'s still not ready. New features, a reworked core, lots of \\r\\nbug fixes, new tools, and much more are waiting for the release. Stay tuned for the next posts!"},{"id":"/2021/08/06/todo-csharp","metadata":{"permalink":"/blog/2021/08/06/todo-csharp","source":"@site/blog/2021-08-06-todo-csharp.mdx","title":"How to write a Todo list app in 10 lines of code in pure C# [no dependencies]","description":"This tutorial shows how to write to do app in 10 lines of code in pure C#.","date":"2021-08-06T00:00:00.000Z","formattedDate":"August 6, 2021","tags":[{"label":"code","permalink":"/blog/tags/code"},{"label":"programming","permalink":"/blog/tags/programming"},{"label":"funny","permalink":"/blog/tags/funny"}],"readingTime":1.265,"truncated":true,"authors":[{"name":"Krzysztof Krysi\u0144ski","title":"PixiEditor Creator","url":"https://krysinski.me","imageURL":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4"}],"frontMatter":{"title":"How to write a Todo list app in 10 lines of code in pure C# [no dependencies]","author":"Krzysztof Krysi\u0144ski","author_title":"PixiEditor Creator","author_url":"https://krysinski.me","author_image_url":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4","tags":["code","programming","funny"],"keywords":["todo","to-do","list","csharp","programming"],"description":"This tutorial shows how to write to do app in 10 lines of code in pure C#."},"prevItem":{"title":"Devlog 1 v0.1.7","permalink":"/blog/2021/11/13/devlog1"},"nextItem":{"title":"Dynamic bitmaps","permalink":"/blog/2021/07/22/dynamic-bitmaps"}},"content":"Show me the one programmer who didn\'t want to write its own todo list app. In this article, I\'ll show you how\\r\\nto do that in 10 lines of code, without any external dependencies. Yes, really.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Talk is cheap, show me the code\\r\\n\\r\\nSo, let\'s start with a new console app in .NET 5\\r\\n\\r\\n![New Console App](/img/blog-posts/todo-csharp/newproj.png)\\r\\n\\r\\nLet\'s give it a name\\r\\n\\r\\n![Todo App Name](/img/blog-posts/todo-csharp/todoname.png)\\r\\n\\r\\nNow select .NET 5\\r\\n\\r\\n![Select .NET 5](/img/blog-posts/todo-csharp/dotnet5.png)\\r\\n\\r\\n## Great! Coding time\\r\\n\\r\\nSo, you ask me, how on earth, are you going to implement todo app in 10 lines of code?\\r\\n\\r\\nThe answer is simple, let me explain it step by step.\\r\\n\\r\\nLet\'s start with defining your todo tasks.\\r\\n\\r\\n```csharp\\r\\nBuyMilk();\\r\\nBakeCookies();\\r\\nTalkToYourGrandma();\\r\\nWatchTv();\\r\\nCode();\\r\\n```\\r\\n\\r\\nawesome, tasks defined. Now, go complete them, and after each completed task, come back to your pc and\\r\\nwrite a method. Like that\\r\\n\\r\\n```csharp\\r\\nBuyMilk();\\r\\nBakeCookies();\\r\\nTalkToYourGrandma();\\r\\nWatchTv();\\r\\nCode();\\r\\n\\r\\nvoid BuyMilk() { }\\r\\n```\\r\\n\\r\\nAfter you complete all of your tasks, your program will compile, which means, \\r\\nyou have completed your todo list and app at the same time!\\r\\n\\r\\nYou can see which tasks are completed and which are not, in the real time.\\r\\n\\r\\nBonus points if your code editor highlights existing methods with green color, and undefined with red. \\r\\n\\r\\nThis is a final code \\r\\n```csharp\\r\\nBuyMilk();\\r\\nBakeCookies();\\r\\nTalkToYourGrandma();\\r\\nWatchTv();\\r\\nCode();\\r\\n\\r\\nvoid BuyMilk() { }\\r\\nvoid BakeCookies() { } ;\\r\\nvoid WatchTv() { }\\r\\nvoid TalkToYourGrandma() { }\\r\\nvoid Code() { }\\r\\n```\\r\\n\\r\\nThank you for coming to my TED talk."},{"id":"/2021/07/22/dynamic-bitmaps","metadata":{"permalink":"/blog/2021/07/22/dynamic-bitmaps","source":"@site/blog/2021-07-22-dynamic-bitmaps.mdx","title":"Dynamic bitmaps","description":"Dynamic bitmap is a solution which made PixiEditor work multiple times faster, decreased RAM usage 10 times, and solved memory leak problems.  This article will explain what it is and how it works.","date":"2021-07-22T00:00:00.000Z","formattedDate":"July 22, 2021","tags":[{"label":"code","permalink":"/blog/tags/code"},{"label":"solution","permalink":"/blog/tags/solution"}],"readingTime":5.39,"truncated":true,"authors":[{"name":"Krzysztof Krysi\u0144ski","title":"PixiEditor Creator","url":"https://krysinski.me","imageURL":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4"}],"frontMatter":{"title":"Dynamic bitmaps","author":"Krzysztof Krysi\u0144ski","author_title":"PixiEditor Creator","author_url":"https://krysinski.me","author_image_url":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4","tags":["code","solution"],"keywords":["bitmap","dynamic","data-structure","image","optimization"],"description":"Dynamic bitmap is a solution which made PixiEditor work multiple times faster, decreased RAM usage 10 times, and solved memory leak problems.  This article will explain what it is and how it works."},"prevItem":{"title":"How to write a Todo list app in 10 lines of code in pure C# [no dependencies]","permalink":"/blog/2021/08/06/todo-csharp"},"nextItem":{"title":"Launching PixiEditor.net","permalink":"/blog/2021/06/06/pixieditor-net-launch"}},"content":"Dynamic bitmaps are a solution that made PixiEditor work multiple times faster, decreased RAM usage by about 10 times and solved memory leak problems. \\r\\nThis article will explain what dynamic bitmaps are and how they work.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## History\\r\\n\\r\\nDynamic bitmaps have been introduced in a very early alpha (version v0.0.3), before that the PixiEditor image system was pretty straightforward.\\r\\n\\r\\nMouse clicks were converted into relative canvas coordinates, and then color was applied to the pixels at a given position. It was pretty simple, however, this solution had one big downside. PixiEditor uses [WriteableBitmap](https://docs.microsoft.com/pl-pl/dotnet/api/system.windows.media.imaging.writeablebitmap?view=net-5.0)\\r\\nto manipulate bitmaps and working on bigger canvases using this solution yielded bad performance and huge memory consumption.\\r\\n\\r\\nSo what was the solution? Dynamic bitmaps!\\r\\n\\r\\n## What is a dynamic bitmap?\\r\\n\\r\\nIn simple words, a dynamic bitmap is a bitmap that fits the size of its content. This is crucial for the layer system.\\r\\nHere is a visual representation of how it works \\r\\n\\r\\n<video width=\\"650\\" controls>\\r\\n  <source src=\\"/videos/dynamic-bitmaps.mp4\\" type=\\"video/mp4\\"/>\\r\\n</video>\\r\\n\\r\\n## How it works\\r\\n\\r\\nLet\'s start with a simple algorithm\\r\\n\\r\\n```\\r\\n1. Create a new bitmap with a size of 0x0 (or of any other size, depending on your usage)\\r\\n2. When set pixel is requested (for example user clicked on canvas), do the following:\\r\\n3. If the color is not transparent (if alpha is not 0):\\r\\n\\r\\n  a. If X of given coordinates is bigger than current width or Y is bigger than height, Increase size to bottom right\\r\\n\\r\\n  b. Else if new colored pixel X is smaller than 0 (relative to bitmap coordinates) or Y is smaller than 0, then increase the size to top left\\r\\n  \\r\\n4. Else If: color is transparent and coordinates already contain non-transparent pixel and after deleting them, there is a gap between content and the bitmap:\\r\\n  a. Decrease size of bitmap to fit content\\r\\n  ```\\r\\n\\r\\n  The process of resizing the bitmap is quite simple:\\r\\n\\r\\n  ```\\r\\n  1. Create a new bitmap with the desired size\\r\\n  2. Copy pixels from the current bitmap\\r\\n  3. Fill a new bitmap with the copied pixels at a calculated offset.\\r\\n  ```\\r\\n\\r\\n  However, the implementation is not trivial, it requires some calculations, like extracting the border pixels, calculating offsets,\\r\\n   checking if a coordinate is a border pixel and more.\\r\\n\\r\\n   ## How PixiEditor does this\\r\\n\\r\\n   Our algorithms look like this:\\r\\n\\r\\n   ```csharp\\r\\n        public void DynamicResize(BitmapPixelChanges pixels)\\r\\n        {\\r\\n            if (pixels.ChangedPixels.Count == 0)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            ResetOffset(pixels);\\r\\n            Tuple<DoubleCords, bool> borderData = ExtractBorderData(pixels);\\r\\n            DoubleCords minMaxCords = borderData.Item1;\\r\\n            int newMaxX = minMaxCords.Coords2.X - OffsetX;\\r\\n            int newMaxY = minMaxCords.Coords2.Y - OffsetY;\\r\\n            int newMinX = minMaxCords.Coords1.X - OffsetX;\\r\\n            int newMinY = minMaxCords.Coords1.Y - OffsetY;\\r\\n\\r\\n            if (!(pixels.WasBuiltAsSingleColored && pixels.ChangedPixels.First().Value.A == 0)) //Check if all requested pixels are transparent\\r\\n            {\\r\\n                if ((newMaxX + 1 > Width && Width < MaxWidth) || (newMaxY + 1 > Height && Height < MaxHeight))\\r\\n                {\\r\\n                    IncreaseSizeToBottomAndRight(newMaxX, newMaxY);\\r\\n                }\\r\\n\\r\\n                if ((newMinX < 0 && Width < MaxWidth) || (newMinY < 0 && Height < MaxHeight))\\r\\n                {\\r\\n                    IncreaseSizeToTopAndLeft(newMinX, newMinY);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // if clip (fit bitmap to content) is requested\\r\\n            if (borderData.Item2)\\r\\n            {\\r\\n                clipRequested = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private void IncreaseSizeToBottomAndRight(int newMaxX, int newMaxY)\\r\\n        {\\r\\n            if (MaxWidth - OffsetX < 0 || MaxHeight - OffsetY < 0)\\r\\n            {\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            newMaxX = Math.Clamp(Math.Max(newMaxX + 1, Width), 0, MaxWidth - OffsetX);\\r\\n            newMaxY = Math.Clamp(Math.Max(newMaxY + 1, Height), 0, MaxHeight - OffsetY);\\r\\n\\r\\n            ResizeCanvas(0, 0, 0, 0, newMaxX, newMaxY);\\r\\n        }\\r\\n\\r\\n        private void IncreaseSizeToTopAndLeft(int newMinX, int newMinY)\\r\\n        {\\r\\n            newMinX = Math.Clamp(Math.Min(newMinX, Width), Math.Min(-OffsetX, OffsetX), 0);\\r\\n            newMinY = Math.Clamp(Math.Min(newMinY, Height), Math.Min(-OffsetY, OffsetY), 0);\\r\\n\\r\\n            Offset = new Thickness(\\r\\n                Math.Clamp(OffsetX + newMinX, 0, MaxWidth),\\r\\n                Math.Clamp(OffsetY + newMinY, 0, MaxHeight),\\r\\n                0,\\r\\n                0);\\r\\n\\r\\n            int newWidth = Math.Clamp(Width - newMinX, 0, MaxWidth);\\r\\n            int newHeight = Math.Clamp(Height - newMinY, 0, MaxHeight);\\r\\n\\r\\n            int offsetX = Math.Abs(newWidth - Width);\\r\\n            int offsetY = Math.Abs(newHeight - Height);\\r\\n\\r\\n            ResizeCanvas(offsetX, offsetY, 0, 0, newWidth, newHeight);\\r\\n        }\\r\\n\\r\\n        private void ResizeCanvas(int offsetX, int offsetY, int offsetXSrc, int offsetYSrc, int newWidth, int newHeight)\\r\\n        {\\r\\n            int iteratorHeight = Height > newHeight ? newHeight : Height;\\r\\n            int count = Width > newWidth ? newWidth : Width;\\r\\n\\r\\n            using (BitmapContext srcContext = LayerBitmap.GetBitmapContext(ReadWriteMode.ReadOnly))\\r\\n            {\\r\\n                WriteableBitmap result = BitmapFactory.New(newWidth, newHeight);\\r\\n                using (BitmapContext destContext = result.GetBitmapContext())\\r\\n                {\\r\\n                    for (int line = 0; line < iteratorHeight; line++)\\r\\n                    {\\r\\n                        int srcOff = (((offsetYSrc + line) * Width) + offsetXSrc) * SizeOfArgb;\\r\\n                        int dstOff = (((offsetY + line) * newWidth) + offsetX) * SizeOfArgb;\\r\\n                        BitmapContext.BlockCopy(srcContext, srcOff, destContext, dstOff, count * SizeOfArgb);\\r\\n                    }\\r\\n\\r\\n                    LayerBitmap = result;\\r\\n                    Width = newWidth;\\r\\n                    Height = newHeight;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        private Tuple<DoubleCords, bool> ExtractBorderData(BitmapPixelChanges pixels)\\r\\n        {\\r\\n            Coordinates firstCords = pixels.ChangedPixels.First().Key;\\r\\n            int minX = firstCords.X;\\r\\n            int minY = firstCords.Y;\\r\\n            int maxX = minX;\\r\\n            int maxY = minY;\\r\\n            bool clipRequested = false;\\r\\n\\r\\n            foreach (KeyValuePair<Coordinates, Color> pixel in pixels.ChangedPixels)\\r\\n            {\\r\\n                if (pixel.Key.X < minX)\\r\\n                {\\r\\n                    minX = pixel.Key.X;\\r\\n                }\\r\\n                else if (pixel.Key.X > maxX)\\r\\n                {\\r\\n                    maxX = pixel.Key.X;\\r\\n                }\\r\\n\\r\\n                if (pixel.Key.Y < minY)\\r\\n                {\\r\\n                    minY = pixel.Key.Y;\\r\\n                }\\r\\n                else if (pixel.Key.Y > maxY)\\r\\n                {\\r\\n                    maxY = pixel.Key.Y;\\r\\n                }\\r\\n\\r\\n                if (clipRequested == false && IsBorderPixel(pixel.Key) && pixel.Value.A == 0)\\r\\n                {\\r\\n                    clipRequested = true;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            return new Tuple<DoubleCords, bool>(\\r\\n                new DoubleCords(new Coordinates(minX, minY), new Coordinates(maxX, maxY)), clipRequested);\\r\\n        }\\r\\n\\r\\n        private bool IsBorderPixel(Coordinates cords)\\r\\n        {\\r\\n            return cords.X - OffsetX == 0 || cords.Y - OffsetY == 0 || cords.X - OffsetX == Width - 1 ||\\r\\n                   cords.Y - OffsetY == Height - 1;\\r\\n        }\\r\\n```\\r\\n\\r\\nAs you can see, the code is not trivial, it takes a lot of steps, our implementation also does a bit more stuff, like requesting clips \\r\\n(resizing whole document to perfectly fit the content) and clamping the maximum size. \\r\\n\\r\\n## Performance\\r\\n\\r\\nOur implementation is very performant since we are using fast `BitmapContext.BlockCopy` to copy and paste pixels into a new bitmap.\\r\\n\\r\\nIt\'s almost unnoticeable in real-time, with fast mouse movement small visual jittering can be visible, but there is no delay whatsoever.\\r\\nHow fast dynamic bitmaps work, depends on the implementation, platform, native bitmap APIs, etc.\\r\\n\\r\\n## Other benefits\\r\\n\\r\\nThe benefits described below are not directly related to the implementation, but the usage of dynamic bitmaps.\\r\\n\\r\\nThese features are way easier to create (or possible at all), thanks to perfectly fitted bitmaps:\\r\\n- Resize and rotate border,\\r\\n- Clip canvas (fit document to content),\\r\\n- Center content relative to document or other layers,\\r\\n- Snapping and guides\\r\\n- Efficient preview layers\\r\\n\\r\\n## Conclusion\\r\\n\\r\\nDynamic bitmaps are a very useful structure, it helps to create a lot of small bitmaps, which can be easily reused. \\r\\nNo more unnecessary memory allocation and heavy CPU operations. If you want to learn more, \\r\\njoin our [Discord](https://discord.gg/qSRMYmq), we are open to discussions!"},{"id":"/2021/06/06/pixieditor-net-launch","metadata":{"permalink":"/blog/2021/06/06/pixieditor-net-launch","source":"@site/blog/2021-06-06-pixieditor-net-launch.mdx","title":"Launching PixiEditor.net","description":"PixiEditor.net has launched!","date":"2021-06-06T00:00:00.000Z","formattedDate":"June 6, 2021","tags":[{"label":"pixieditornet","permalink":"/blog/tags/pixieditornet"},{"label":"website","permalink":"/blog/tags/website"},{"label":"launch","permalink":"/blog/tags/launch"}],"readingTime":0.235,"truncated":true,"authors":[{"name":"Krzysztof Krysi\u0144ski","title":"PixiEditor Creator","url":"https://krysinski.me","imageURL":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4"}],"frontMatter":{"title":"Launching PixiEditor.net","author":"Krzysztof Krysi\u0144ski","author_title":"PixiEditor Creator","author_url":"https://krysinski.me","author_image_url":"https://avatars.githubusercontent.com/u/25402427?s=400&v=4","tags":["pixieditornet","website","launch"],"description":"PixiEditor.net has launched!","hide_table_of_contents":false},"prevItem":{"title":"Dynamic bitmaps","permalink":"/blog/2021/07/22/dynamic-bitmaps"}},"content":"\ud83c\udf89 PixiEditor.net has launched! \ud83c\udf89\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\nOur official website has finally launched! From now on, everything related to project will be posted here along with our social-medias.\\r\\nYou can now download PixiEditor from our website, read docs (GitHub wiki docs will be archived) and read blog posts."}]}')}}]);